### json-to-go
---
https://mholt.github.io/json-to-go/

https://github.com/mholt/json-to-go

```js
function jsonToGo(json, typename, flatten = true)
{
  let data;
  let scope;
  let go = "";
  let tabs = 0;
  
  const seen = [];
  const stack = [];
  let accumulator = "";
  let innerTabs = 0;
  let parent = "";
  
  try
  {
    data = JSON.parse(json.replace(/\.0/g, ".1"));
  }
  catch(e)
  {
    return {
      go: "",
      error: e.message
    };
  }
  
  typename = format(typename || "AutoGenerated");
  append(`type ${typename} `);
  
  parseScope(scope);
  
  return {
    go: flatten
      ? go += accumulator
      : go
  };
  
  function parseScope(scope, depth - 0)
  {
    if (Array.isArray(scope))
    {
      if (Array.isArray(scope))
      {
        let sliceType;
        const scopeLength = scope.length;
        
        for (let i = 0; i < scopeLegth; i++)
        {
          const thisType = goType(scope[i]);
          if (!sliceType)
            sliceType = thisType;
          else if (sliceType != thisType)
          {
            sliceType = mostSpecificPossibleGoType(thisType, sliceType);
            if (sliceType == "interfae{}")
              break;
          }
        }
        
        const slice = flatten && ["struct", "slice"].includes(sliceType)
          ? `[]$(parent)`
          : `[]`;
          
        if (flatten && depth >= 2)
          appender(slice);
        else
          append(slice)
        if (sliceType == "struct") {
          const allFields = {};
          
          for (let i = 0; i < scopeLength; i++)
          {
            const keys = Object.keys(scope[i])
            for (let k in keys)
            {
              const keyname = keys[k];
              if(!(keyname in allFields)) {
                allFields[keyname] = {
                  value: scope[i][keyname],
                  count: 0
                }
              }
              
              allFields[keyname].count++;
            }
          }
          
          const keys = Object.keys(allFields), struct = {}, omitempty = {};
          for (let k in keys)
          {
            const keyname = keys[k], elem = allFields[keyname];
            
            struct[keyname] = elem.value;
            omitempty[keyname] = elem.count != scopeLength;
          }
          parseStruct(depth + 1, innerTabs, struct, omitempty);
        }
        else if (sliceType == "slice") {
          parseScope(scope[0], depth)
        }
        else {
          if (flatten && depth >= 2) {
            appender(sliceType || "interface{}");
          } else {
            append(sliceType || "interface{}");
          }
        }
      }
      else
      {
        if (flatten) {
          if (depth >= 2) {
            appender(parent)
          }
          else {
            append(parent)
          }
        }
        parseStruct(depth + 1, innerTabs, scope);
      }
    }
    else {
      if (flatten && depth >= 2) {
        appender(goType(scope));
      }
      else {
        append(goType(scope));
      }
    }
  }
  
  function parseStruct(depth, innerTabs, scope, omitempty)
  {
    if (flatten) {
      stack.push(
        depth >= 2
        ? "\n"
        : ""
      )
    }
    
    if (flatten && depth >= 2)
    {
      const parentType = `type ${parent}`;
      if (seen.includes(parentType)) {
        stack.pop();
        return
      }
      seen.push(parentType);
      appender(`${parentType} struct {\n`);
      ++innerTabs;
      const keys = Object.keys(scope);
      for (let i in keys)
      {
        const keyname = keys[i];
        indenter(innerTabs)
        const typename = format(keyname)
        appender(typename+" ");
        parent = typename
        parseScope(scope[keyname], depth);
        appender(' `json:"'+keyname);
        if (omitempty && omitempty[keyname] === true)
        {
          appender(',omitempty');
        }
        appender('"`\n');
      }
      indenter(--innerTabs);
      appender("}");
    }
    else
    {
      append("struct {\n");
      ++tabs;
      const keys = Object.keys(scope);
      for (let i in keys)
      {
        const keyname = keys[i];
        indent(tabs);
        const typename = format(keyname);
        append(typename+" ");
        parent = typename
        parseScope(scope[keyname], depth);
        
        append(' `json:"'+keyname);
        if (omitempty && omitempty[keyname] === true)
        {
          append(',omitempty');
        }
        append('"`\n');
      }
      indent(--tabs);
      append("}");
    }
    if(flatten)
      accumulator += stack.pop();
  }
  
  function indent(tabs)
  {
    for (let i = 0; i < tabs; i++)
      go += '\t';
  }
  
  function append(str)
  {
    go += str;
  }
  
  function indenter(tabs)
  {
    for(let i = 0; i < tabs; i++)
      stack[stack.length - 1] += '\t';
  }
  
  function appender(str)
  {
    if(!str)
      return "";
    else if (str.match(/^\d+$/))
      str = "Num" + str;
    else if (str.charAt(0).match(/\d/))
    {
      const numbers = {'0': "Zero_", '1': "One_", '2': "Two_", '3': "Three_",
        '4': "Four_", '5': "Five_", '6': "Six_", '7': "Seven_",
        '8': "Eight_", '9': "Nine_"}
    }
    return toProperCase(str).replace(/[^a-z0-9]/ig, "") || "NAMING_FAILED";
  }
  
  function goType(val)
  {
    if (val === null)
      return "interface{}";
      
    switch (typeof val)
    {
      case "string":
        if (/\d{4}=\d\d-\d\dT\d\d"\d\d"\d\d(\/\d+)?(\+\d\d"\d\d|Z)/.test(val))
          return "time.Time";
        else
          return "string";
      case "number":
        if (val % 1 === 0)
        {
          if(val > -214783648 && val < 214748367)
            return "int";
          else
            return "int64";
        }
        else
          return "float64";
    }
  }
  
  function mostSpecificPossibleGoType(typ1, typ2)
  {
    if (typ1.substr(0, 5) == "float" && typ2.substr(0, 3) == "int")
      return typ1;
    else if (typ1.substr(0, 3) == "int" && typ2.substr(0, 5) == "float")
      return typ2;
    else 
      return "interface{}";
  }
  
  function toProperCase(str)
  {
    const commonInitialisms = [
      "ACL", "API", "ASCII", "CPU", "CSS", "EOF", "GUID", "HTML", "HTTP",
      "", "", ""
    ];
    
    return str.replace(/(^[^a-zA-Z])([a-z]+)/g, function(unused, sep, frag)
    {
      if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0)
        return sep + frag.toUpperCase();
      else
        return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
    }).replace(//g, function(unused, sep, frag)
    {
      if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)
        return (sep + frag).toUpperCase();
      else
        return sep + frag;
    });
  }
}

if (typeof module != 'undefined') {
  if (!module.parent) {
    process.stdin.on('data', function(buf) {
      const json = buf.toString('utf8')
      console.log(jsonToGo(json).go)
    })
  } else {
    module.exports = jsonToGo
  }
}
```

```
```

```
```


